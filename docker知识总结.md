### docker知识总结 ###

#### 容器化的原因 ####
单体应用拆分成微服务后,它的管理成本增加:    
1 服务部署,测试,发布方式更复杂   
2 服务扩容出现了环境差异   

#### 服务设计原则 ####
服务采用独立容器设计:

    不依赖宿主机
    组件对外提供一致性接口
    服务在初始化阶段从环境变量中获取参数
    应用产生的数据应该通过volumes存储在容器外部或者数据容器中


#### docker核心 ####
Docker使用操作系统的功能来提高容器技术效率:

- Namespaces 环境隔离    
	确保容器中运行的一个进程且不能看到或影响容器外的其他进程.

- Control Groups 
	LXC的重要组成部分,具有资源核算与限制的关键功能

- UnionFS 文件系统
	容器的构建块.通过用户层支持docker的轻量级和快速

 
#### cgroups和union文件系统 ####

docker使用cgroup来提供容器隔离;

Control Groups用于容器隔离，具有以下功能：

- 限制Linux进程组的资源占用(内存,cpu)   
	负责资源核算和限制。   
	提供CPU、内存、I/O和网络相关的指标。   

- 为进程组制作PID,UTS,IPC,网络,用户及装载命名空间   
	避免某种DoS攻击。   
	支持多租户平台。   


union文件系统用于保存镜像并使容器变得短暂;
	Union文件系统允许通过union装载来达到一个分层的累积变化.
	不同步骤的文件系统,被拆分为不同的层,通过分层来复用和增加灵活性

容器
	容器之所以短暂,是因为从镜像上创建容器,docker会创建一个空白 union文件系统加载在与该镜像关联的union文件系统之上.
	这也意味这当容器停止,该容器的union文件系统会销毁.除非你创建一个新镜像或制作一个卷.(存在数据持久化问题)

#### docker api ####

实际和docker deamon交互都是通过rest api完成,具体api种类可以分为四种:

docker registry api
docker hub api
docker oauth api
docker remote api

### 最佳实践 ###
- docker daemon

下面介绍一些需要注意的地方：
当Docker允许与访客容器目录共享而不限制其访问权限时，Docker Daemon的控制权应该只给授权用户。
REST API支持Unix sockets，从而防止了cross-site-scripting攻击。
REST API的HTTP接口应该在可信网络或者VPN下使用。
在服务器上单独运行Docker时，需要与其它服务隔离。

一些关键的Docker安全特性包括：
容器以非特权用户运行。
Apparmor、SELinux、GRSEC解决方案，可用于额外的安全层。
可以使用其它容器系统的安全功能。


- docker build

应采用多步骤构建,dockerfile中构建步骤应该按照构建的变化大小从小到大排序,这样可以尽多的重用不变的步骤
变化大小依据:

- 安装工具步骤
- 安装和更新依赖库
- 生成应用

最小化构建层

原则上最小化构建层可以保证镜像的性能,但是下面情况例外:

- 除了RUN COPY ADD创建层命令外,其他命令只会创建临时镜像,不会增加构建大小
- 尽可能采用多步骤构建,只复制你需要的内容到镜像中.



#### docker 镜像 ####

实际可分为四层:

- 基础环境层

定义操作系统运行版本,时区,语言,yum源,term等

- 运行时环境层

业务代码运行时环境.如Java代码的jdk

- web容器层

业务代码运行时容器配置.如tomcat配置

- 业务代码层

实际业务代码


#### 网络 ####

本地网络:容器间,容器和宿主机间通信

覆盖网络:宿主机间网络整合为通一的网络.


#### 注意事项 ####

1 集群服务命名应采取:名字+主机名的方式,便于问题定位
2 代码构建版本化,可以使用git commit sha



































